---
title: "NLP"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r}
library(data.table)
library(plotly)
library(readr)
library(mxnet)
library(tictoc)
library(stringi)
library(aws.s3)

source("conv_encode.R")
source("conv_decode.R")
source("model_rnn.R")
source("metrics.R")
```

### Load buckets

```{r}
buckets <- read_rds("data/buckets_euro_en_fr_10_50.rds")
# buckets <- s3readRDS(object = "translatR/data/euro/buckets_euro_en_fr_4_24.rds", bucket = "nimus-data")
```


```{r}
### Validation
# data <- buckets$buckets$`24`$data
# label <- buckets$buckets$`24`$label
# 
# source_dic <- buckets$source_dic
# target_dic <- buckets$target_dic
# 
# setkeyv(target_dic, "word_id")
# setkeyv(source_dic, "word_id")
# 
# source_test <- data[,800001] + 1
# source_dic[source_test]
# 
# target_test <- label[,800001] + 1
# target_dic[target_test]
```


### Model architecture

```{r}
source_input_size = nrow(buckets$source_dic)
target_input_size = nrow(buckets$target_dic)

batch_size = 128
num_hidden = 512
num_embed = 512
seq_len = 50

encode <- conv.graph.encode(input_size = source_input_size, num_embed = num_embed, loss_output = NULL, ignore_label = -1, masking = T, num_hidden = num_hidden, dropout = 0.2, prefix = "encode_", data_name = "data", label_name = "dummy1")

decode <- conv.graph.decode(encode = encode, input_size = NULL, num_embed = NULL, config = "one-to-one", loss_output =  "softmax", ignore_label = 0, masking = F, num_hidden = num_hidden, dropout = 0.2, num_decode = target_input_size, prefix = "decode_", label_name = "label")

# graph.viz(encode, shape = c(seq_len, batch_size))
# graph.viz(decode)
# graph.viz(decode, shape = list(data = c(seq_len, batch_size), label = c(seq_len, batch_size)))

encode$arguments
shapes = encode$infer.shape(list(data=c(seq_len, batch_size)))

decode$arguments
shapes = decode$infer.shape(list(data=c(seq_len, batch_size), label=c(seq_len, batch_size)))
# shapes = decode$infer.shape(list(data=c(seq_len, batch_size)))


shapes_out = shapes$out.shapes
shapes_arg = shapes$arg.shapes
```

### Prepare iterators 

```{r}
# potential buggy records between 1248000 and 1272000
# dim(buckets$buckets$`50`$data[, -(1248000:1272000)])
# dim(buckets$buckets$`50`$label[, -(1248000:1272000)])
iter_train <- mx.io.arrayiter(data = buckets$buckets$`50`$data[, -(1248000:1272000)], label = buckets$buckets$`50`$label[, -(1248000:1272000)], batch.size = batch_size, shuffle = F)

iter_train$reset()
iter_train$iter.next()
iter_data = iter_train$value()
dim(iter_data$label)
```

### Launch training

```{r}
# ctx <- mx.cpu()
ctx <- mx.gpu(0)

initializer <- mx.init.Xavier(rnd_type = "gaussian", factor_type = "in", magnitude = 2.5)

lr_scheduler = mx.lr_scheduler.FactorScheduler(step = 5000, factor_val = 0.5, stop_factor_lr = 1e-5, verbose = T)

# no grad rescale since using "valid" scaling option in SoftmaxOutput
optimizer <- mxnet:::mx.opt.adam(learning.rate = 1e-3, beta1 = 0.9, beta2 = 0.999,
                                 epsilon = 1e-8, wd = 0, clip_gradient = 1,
                                 rescale.grad=1, lr_scheduler = lr_scheduler)


epoch.end.callback <- mx.callback.log.train.metric(period = 1)
batch.end.callback <- mx.callback.log.speedometer(batch.size = batch_size, frequency = 50)

system.time(
  model <- mx.model.buckets(symbol = decode,
                            train.data = iter_train, 
                            eval.data = NULL,
                            num.round = 3, ctx = ctx, verbose = TRUE,
                            metric = mx.metric.Perplexity, 
                            optimizer = optimizer,  initializer = initializer,
                            batch.end.callback = batch.end.callback, 
                            epoch.end.callback = epoch.end.callback, metric_cpu = F)
)

mx.model.save(model = model, prefix = "models/model_euro_en_fr_conv_1", iteration = 0)
```


## Inference

```{r}
model <- mx.model.load(prefix = "models/model_euro_en_fr_conv_1", iteration = 0)
ctx <- mx.gpu(0)

source_dic <- buckets$source_dic
target_dic <- buckets$target_dic
setkeyv(source_dic, "word")
setkeyv(target_dic, "word_id")

infer_helper <- function(infer_seq, model, source_dic, target_dic) {
  
  infer_seq <- paste("<BOS>", infer_seq, "<EOS>")
  infer_seq <- stri_split_boundaries(infer_seq, type = "word", 
                                     skip_word_none = T, 
                                     skip_word_number = F, 
                                     simplify = T)
  
  infer_seq <- data.table(t(infer_seq))
  infer_dt <- source_dic[infer_seq]
  
  infer_mat <- matrix(0, nrow = 50, ncol = 1)
  infer_mat[1:length(infer_dt$word_id), 1] <- infer_dt$word_id
  
  iter_infer <- mx.io.arrayiter(data = infer_mat, label = infer_mat, batch.size = 1, shuffle = F)
  
  infer_pred <- mx.infer.rnn(infer.data = iter_infer, model = model, ctx = ctx)
  dim(infer_pred)
  
  infer_nd <- mx.nd.array(infer_pred)
  infer_max <- as.array(mx.nd.argmax(infer_nd, axis = 1))
  
  translation <- target_dic[infer_max+1]
  return(translation)
}

infer_helper(infer_seq = "tomorrow i want to discuss about the law in the parliament",
             model = model, source_dic = source_dic, target_dic = target_dic)

infer_helper(infer_seq = "she is a great person",
             model = model, source_dic = source_dic, target_dic = target_dic)

infer_helper(infer_seq = "i am minister",
             model = model, source_dic = source_dic, target_dic = target_dic)

infer_helper(infer_seq = "the government is my friend",
             model = model, source_dic = source_dic, target_dic = target_dic)
```

